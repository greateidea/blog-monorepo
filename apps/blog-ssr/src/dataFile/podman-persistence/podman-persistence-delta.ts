import { getSafeHtmlFromDelta } from "../../utils"

const deltaString = {"ops":[{"insert":"在之前的实践中，我们通过命令创建并启动了Podman容器，但一旦我们退出命令行，容器也会随之退出，这肯定不是我们想要的。这次，我们就来解决这个问题，让我们的容器能够服务持久化，即便退出命令行也能继续运行我们的容器，并且容器能够伴随服务器的重启而重启。接下来，我们通过几个简单的步骤来完成这件事吧。\n\n修改启动命令"},{"attributes":{"header":2},"insert":"\n"},{"insert":"首先，我们需要先简单的改变一下之前我们启动的命令：将之前命令中的  "},{"insert":{"blue700-tag":{"id":1762162959946,"text":"run","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 改为 "},{"insert":{"blue700-tag":{"id":1762162978376,"text":"create","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"，并删除原命令中的 "},{"insert":{"blue700-tag":{"id":1762163014060,"text":"--rm","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 和 "},{"insert":{"blue700-tag":{"id":1762163856970,"text":"-d","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 参数。如此一来，我们的容器将不会在执行命令后立即启动，而是仅仅先创建容器，并且不会在容器停止后立即删除了，这样可以让服务器重启后也重新启动这个容器。改变后的完整命令将会是这个样子：\n\n创建nginx的命令：\npodman create --name my-custom-openresty-container \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --pod your-pod \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret source=load_stage,target=/run/secrets/load_stage,type=mount \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e LOAD_STAGE_FILE=/run/secrets/load_stage \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/nginxConf/nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf:ro \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/conf.d:/etc/nginx/conf.d \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/letsencrypt:/etc/letsencrypt:ro \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/audios:/var/secure-audios:ro \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/nginx-logs:/usr/local/openresty/nginx/logs \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" openresty:alpine"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"\n创建node容器的命令：\npodman create --name customer-node-container \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --pod your-pod \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret mongo_app_user,type=mount,target=/run/secrets/mongo_app_user \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret mongo_app_pass,type=mount,target=/run/secrets/mongo_app_pass \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e MONGO_APP_USERNAME_FILE=/run/secrets/mongo_app_user \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e MONGO_APP_PASSWORD_FILE=/run/secrets/mongo_app_pass \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" customer-node-image"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"\n创建mongodb容器的命令：\npodman create \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --name my_mongodb \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --pod your-pod \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret mongo_root_username,type=mount,target=/run/secrets/mongo_root_username \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret mongo_root_password,type=mount,target=/run/secrets/mongo_root_password \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e MONGO_INITDB_ROOT_USERNAME_FILE=/run/secrets/mongo_root_username \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e MONGO_INITDB_ROOT_PASSWORD_FILE=/run/secrets/mongo_root_password \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v mongodb_data:/data/db:Z \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/mongodb_init/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:Z \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --user mongodb \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --security-opt no-new-privileges \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --memory=1g \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --memory-swap=1g \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --health-interval=30s \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" mongo \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --wiredTigerCacheSizeGB 1"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"\n如果你还没有创建 pod 的话：\npodman pod create --name your-pod -p 443:443 -p 8080:8080"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"\n我们分别执行以上的命令，先创建好所有的容器和它们共同的pod。\n\n将命令转化为.service文件"},{"attributes":{"header":2},"insert":"\n"},{"insert":"接下来需要做的事情将，就是将我们的每个容器命令都转化一个对应的.service文件。这个文件仅仅就是将命令中的具体命令、选项和参数以键值对的形式保存起来，如果你今后足够熟悉的话也可以手动写这个文件。不过为了省去手动书写文件的麻烦，我们还是使用生成.service文件的命令来帮我们完成这件事吧。\n\n在执行完第一步的容器创建命令后，我们应该已经有了三个容器了，分别是 “my-custom-openresty-container”、“customer-node-container”、“my_mongodb”、以及一个 “your-pod”。只是它们还没启动，不过很快你就会看见它们启动起来并持久地运行。\n\n我们再执行以下三条命令：\npodman generate systemd --name my_mongodb --new --files"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"podman generate systemd --name customer-node-container --new --files"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"podman generate systemd --name my-custom-openresty-container --new --files"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"这三条命令分别为我们的每个容器都创建好了一个对应的.service文件，并放在当前执行命令的目录下，它们的名字分别是：\n\n“"},{"insert":{"blue700-tag":{"id":1762165528952,"text":"container-my_mongodb.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"”、\n“"},{"insert":{"blue700-tag":{"id":1762165533171,"text":"container-customer-node-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"”、\n“"},{"insert":{"blue700-tag":{"id":1762165540069,"text":"container-my-custom-openresty-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"”\n\n这三个文件的作用是记录容器的参数，并将自身交由"},{"attributes":{"code":true},"insert":"Systemd"},{"insert":"来管理。\n"},{"insert":{"noticeContainer":"<div class=\"blot-notice-content\" id=\"notice-blot\">到这里我们简单介绍下 Systemd 是什么：Systemd 是现代 Linux 系统中的 <strong>系统与服务管理器（System and Service Manager）</strong>，它是用来启动、停止、管理系统服务与资源的核心组件。可以把它理解为“Linux 开机时最先运行的守护进程（PID 1）”，负责管理整个系统的生命周期。Systemd 的一切都围绕 <strong>Unit</strong> 概念展开，每个 unit 通常对应 /etc/systemd/system/ 或 /lib/systemd/system/、~/.config/systemd/user 下的一个配置文件，后缀名如 .service、.mount 等。</div>"}},{"insert":"\n确定.service文件的依赖顺序"},{"attributes":{"header":2},"insert":"\n"},{"insert":{"listItemContainer":true}},{"insert":"创建好这三个文件后，我们还需要做一件重要的事情，那就是决定它们的依赖顺序，也就是它们的启动顺序。我们的基本依赖顺序是：nginx容器 -> node容器 -> mongodb容器，所以它们的启动顺序则是反过来的。因此我们需要先告诉 "},{"insert":{"blue700-tag":{"id":1762165540069,"text":"container-my-custom-openresty-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 这个文件它依赖 "},{"insert":{"blue700-tag":{"id":1762165533171,"text":"container-customer-node-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"，而 "},{"insert":{"blue700-tag":{"id":1762165533171,"text":"container-customer-node-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"  则依赖 "},{"insert":{"blue700-tag":{"id":1762165528952,"text":"container-my_mongodb.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"， 这样它们则会按照正确的先后顺序启动。\n为此，我们先打开 "},{"insert":{"blue700-tag":{"id":1762165540069,"text":"container-my-custom-openresty-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 这个文件，找到文件中 "},{"attributes":{"bold":true},"insert":"Unit "},{"insert":"下的 "},{"attributes":{"bold":true},"insert":"Requires"},{"insert":" 和 "},{"attributes":{"bold":true},"insert":"After "},{"insert":"字段，并将它们的值都改为 “container-customer-node-container.service”，"},{"attributes":{"bold":true},"insert":"并保存"},{"insert":"。\n\n同样也将 "},{"insert":{"blue700-tag":{"id":1762165533171,"text":"container-customer-node-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"  中对应的值改为 “container-my_mongodb.service”，"},{"attributes":{"bold":true},"insert":"并保存"},{"insert":"。\n\n转移.service文件并启动"},{"attributes":{"header":2},"insert":"\n"},{"insert":"我们在.service文件所在的目录执行以下命令：\nmkdir -p ~/.config/systemd/user/"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"mv container-*.service ~/.config/systemd/user/"},{"attributes":{"code-block":"bash"},"insert":"\n\n"},{"insert":"systemctl --user daemon-reload"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"systemctl --user enable --now container-my-custom-openresty-container.service"},{"attributes":{"code-block":"bash"},"insert":"\n\n"},{"insert":"loginctl enable-linger $(whoami)"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"~/.config/systemd/user/是由Systemd管理的用户级目录，systemctl 命令：\n"},{"insert":{"blue700-tag":{"id":1762166785091,"text":"systemctl --user daemon-reload","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 告诉 Systemd 将 ~/.config/systemd/user/ 下的.service文件加入今后的管理中。\n"},{"insert":{"blue700-tag":{"id":1762166842964,"text":"systemctl --user enabke --now container-my-custom-openresty-container.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 则是通过启动依赖的最前端来启动它后面的所有依赖以及自身。\n\n"},{"insert":{"blue700-tag":{"id":1762167259925,"text":"loginctl enable-linger $(whoami)","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"  这一命令则告诉Systemd，当前用户的 .service 服务在用户退出或者未登录的情况下依然在后台保持运行，则达到了我们退出命令行依然继续执行服务的效果，并且在服务器重启后也会重启我们的服务。\n\n如果需要停止某一容器例如 “my_mongodb”，则可以使用: "},{"insert":{"blue700-tag":{"id":1762167508511,"text":"systemctl --user stop --now container-my_mongodb.service","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n至此，通过以上努力，我们已经达到了让我们的服务持久化的目的，总结一下我们做了哪些事情：\n"},{"insert":{"listItemContainer":"<div class=\"list-item-container\" id=\"your-custom-id-123\"><div class=\"line-container\"><span class=\"list-index\">1. </span><span class=\"list-content\">修改启动命令</span></div><div class=\"line-container\"><span class=\"list-index\">2. </span><span class=\"list-content\">将命令转化为.service文件</span></div><div class=\"line-container\"><span class=\"list-index\">3. </span><span class=\"list-content\">确定.service文件的依赖顺序</span></div><div class=\"line-container\"><span class=\"list-index\">4. </span><span class=\"list-content\">将.service文件转移至 ~/.config/systemd/user/ 目录下并启动</span></div></div>"}},{"insert":"再解释另一个东西: Quadlet，它其实是Podman官方较为推荐的服务持久化的方式，但是其配置复杂，管理较乱，并且其配置文件受版本影响较大，实际操作和维护起来有相当的难度，并且其依然是通过生成.service文件的方式来实现服务持久化的管理，所以为了简单的事情简单化，我依然推荐使用自己生成.service文件的方式来实现服务持久化。\n"}]}

const safeHtml = getSafeHtmlFromDelta(deltaString)

const result = {
    content: safeHtml.replaceAll('<p></p>','').replaceAll('<p><br></p>', ''),
}

export default result



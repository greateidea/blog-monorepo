import { getSafeHtmlFromDelta } from "../../utils"

const TestDeltaString = {"ops":[{"insert":"Podman是一种容器管理工具，因此在了解在Podman之前我们先了解一下什么是容器。通过这篇文章我将会先让你了解容器的概念以及它和Podman的关系。\n\n什么是容器"},{"attributes":{"header":2},"insert":"\n"},{"insert":"先从容器说起，在传统部署中，你需要装系统、配置环境、装工具等各种依赖。而所谓的容器，就是将这些依赖“打包”在一个标准化的盒子里，无论在哪台机器上运行这个容器，它的行为都是一致的。这也就解决了一个经典的问题：“可是在我的机器上就没有问题呀”。\n\n那怎么做出来一个容器呢？这就要提到镜像，对一个镜像使用运行命令，就会产生一个运行的容器。所以看出来了么，镜像和容器的关系，就如同面向对象编程语言中类与对象的关系。我猜看到这里你肯定要问了，那要怎么做一个镜像呢？没错，得到一个容器的关键其实是制作一个镜像。\n\n制作一个镜像其实非常简单，你只需要一个类似清单一样的文件，列出你需要的基础镜像，需要用到的依赖，执行一些镜像在生成容器过程中的命令，例如切换容器内的工作目录、复制源代码、下载依赖、打包代码等等，然后对这个文件执行一个生成镜像的命令。接下来我们以一个简单的node镜像文件为例。\n\n# 基础镜像为最新的alpha版本的node"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"FROM node:alpha "},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 设定工作目录"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"WORKDIR /usr/src/app"},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 复制依赖文件"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"COPY package.json package-lock.json "},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 下载依赖"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"RUN npm ci --include=dev"},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 复制源代码"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"COPY src ./src"},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 执行构建命令"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"RUN npm build"},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 设置环境变量"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"ENV NODE_ENV=production"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"ENV PORT=3000"},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 列出当前所有文件"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"RUN ls -la ."},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":"# 最后执行运行程序的命令 一个容器就开始运行了"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"CMD [\"node\", \"dist/index.js\"]"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"\n这就是一个镜像文件的大概内容，看到了么，它其实很简单，就像一个记录“流水账”的账单一样，最后我们将其保存为一个名为Dockerfile的文件，这样我们就完成了一个镜像文件。\n\n接下来我们执行构建镜像的命令。在命令行里，将目录切换到镜像文件所在的目录，以podman的命令为例，在命令行执行：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761060428033,"text":"podman build -t customer_name","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n执行这个命令后会生成一个名为customer_name的镜像。命令中的“-t ”就是指镜像名称（tag）。我们还可以在命令行里执行：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761060431479,"text":"podman images","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n命令列出所有的镜像。接下来我们就可以执行：\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761060434863,"text":"podman run -d --name  customer_container_name customer_name","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n来通过这个镜像得到一个运行的容器。这个命令中的“-d”是指在后台（detached）模式下运行，而“--name  customer_container_name”就是给这个容器起一个名字，这之后的“customer_name”则是你之前那个镜像的名字。然后我们可以执行：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761060438381,"text":"podman ps","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n命令列出所有的正在运行的容器。到这里你已经通过编写镜像文件，再构建镜像，然后运行镜得到了一个运行的容器。在这之后，你可以通过在命令行里执行：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761060481348,"text":"podman stop customer_container_name","renderAsBlock":false,"className":"blue700-tag"}}},{"attributes":{"bold":true},"insert":" "},{"insert":"或者 "},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761060485098,"text":"podman stop [id]","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n来停止这个容器（这里的id就是"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761060530515,"text":"podman ps","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"命令中列出的id）。\n\nPodman和容器"},{"attributes":{"header":2},"insert":"\n"},{"insert":"相信到了这里，你已经对Podman已经有了基本的了解。它可以帮助你管理容器的整个生命周期（创建、启动、停止、删除、监控、网络、存储、日志等）。通过"},{"attributes":{"link":"https://podman.io"},"insert":"官网"},{"insert":"可以下载适合平台的内容。\n\n除了Podman以外，还有 Docker、containerd、CRI-O、LXC/LXD 等常见容器引擎，它们各有定位和优势。另外还有Kubernetes这样的容器编排系统，它在更高层次对容器进行分布式管理。说到这里，你可能会发现镜像文件的名字“Dockerfile”似乎和Docker有着千丝万缕的联系，你的感觉是对的，这就不得不提到Podman和Docker的关系。\n\nPodman和Docker"},{"attributes":{"header":2},"insert":"\n"},{"insert":"简单来说，Podman 可以理解为 Docker 的“后起之秀”和“无守护进程版本”。Podman几乎所有的命令都和Docker一样，也就是说将“podman ps”换成“docker ps”就变成了Docker的命令了！\n\n那么它们区别在哪里呢？这得先提到“containerd”，它是一个 "},{"attributes":{"bold":true},"insert":"容器运行时（runtime）"},{"insert":"，最初是 Docker 的一部分，后来被独立出来，成为 CNCF（云原生基金会）维护的独立项目"},{"attributes":{"bold":true},"insert":"。"},{"insert":"它专注于做“容器运行的底层逻辑”：镜像管理、快照、容器生命周期管理等，现在 Kubernetes 等容器编排系统，通常都是通过 containerd 来真正运行容器的。所以Docker容器其实是通过Docker Engine (dockerd)、containerd来执行底层的runc最终运行起来的。而Podman没有 dockerd（无守护进程），使用底层运行时 CRI-O 或直接 runc，可以 rootless 运行。\n\n到此，我们已经理清了Podman和容器的基本概念和逻辑，在之后的内容中，将进一步探索Podman的各种常用命令及其参数，还有它的网络、pod、密钥等相关概念的使用，以及如何构建一些常用的容器。\n"}]}
const safeHtml = getSafeHtmlFromDelta(TestDeltaString)

const result = {
    content: safeHtml,
}

export default result;
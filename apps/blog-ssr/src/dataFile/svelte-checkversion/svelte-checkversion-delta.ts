import { getSafeHtmlFromDelta } from "../../utils"

const TestDeltaString = {"ops":[{"insert":"上次我们深入探索和理解了"},{"attributes":{"bold":true},"insert":"Svelte"},{"insert":"的"},{"attributes":{"bold":true},"insert":"$derived"},{"insert":"是如何运行和实现了，再此基础上我们继续接着深入探索Svelte是如何通过状态转换和和版本检查来更细致的控制更新的。\n\n什么是版本检查？"},{"attributes":{"header":2},"insert":"\n"},{"insert":"Svelte设计了一套版本检查的机制，主要是针对"},{"attributes":{"bold":true},"insert":"$derived"},{"insert":"、"},{"attributes":{"bold":true},"insert":"$effect"},{"insert":"、"},{"attributes":{"bold":true},"insert":"$state"},{"insert":"，这其中对这套机制最主要的承载者是$derived。我们还是先来解释这个机制是如何运作的。\n\n整个响应式系统基本组合是订阅者+依赖，更复杂点的就是依赖又有依赖这样一直链条下去。这个有依赖的“依赖”，它既是下游的订阅者又是上游的依赖，"},{"attributes":{"bold":true},"insert":"$derived"},{"insert":"就是这样一个角色。\n\n每个响应式变量（例如"},{"attributes":{"bold":true},"insert":"$derived、$state"},{"insert":"产生的变量）都一个自己的版本号，这个版本号不是hash，仅是一个每次自身更新后都自加一的数值。\n\n我们以一个基础的组合运作流程来解释，"},{"attributes":{"bold":true},"insert":"$effect"},{"insert":"依赖了一个"},{"attributes":{"bold":true},"insert":"$derived"},{"insert":"变量1，"},{"attributes":{"bold":true},"insert":"$derived变量1"},{"insert":"依赖了一个"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"，"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"依赖了一个"},{"attributes":{"bold":true},"insert":"$state变量"},{"insert":"，并且它们在建立依赖的时候就会记录当前所有依赖的版本号，$effect -> $derived变量1 -> $derived变量2 -> $state变量：\n\n"},{"insert":{"listItemContainer":true}},{"attributes":{"bold":true},"insert":"$state变量"},{"insert":"更新时，会将自己的版本号加一，然后通知"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"；\n"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"收到通知，将自身的状态设置为"},{"attributes":{"bold":true},"insert":"MAYBE_DIRTY"},{"insert":"，然后通知"},{"attributes":{"bold":true},"insert":"$derived变量1"},{"insert":"；\n"},{"attributes":{"bold":true},"insert":"$derived变量1"},{"insert":"收到通知，将自身的状态设置为"},{"attributes":{"bold":true},"insert":"MAYBE_DIRTY"},{"insert":"，然后通知"},{"attributes":{"bold":true},"insert":"$effect"},{"insert":"；\n\n"},{"attributes":{"bold":true},"insert":"$effect"},{"insert":"收到通知，并在之后开始执行的时候，开始检查所有的依赖项是否版本是否变化，重点来了:\n它会要求依赖的$derived变量1立刻检查自己是否需要更新版本号和最新值;\n\n"},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"attributes":{"bold":true},"insert":"$derived变量1"},{"insert":"发现自己"},{"attributes":{"bold":true},"insert":"MAYBE_DIRTY"},{"insert":"，要求依赖的"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"立刻检查自己是否需要更新版本号和最新值;\n"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"发现自己"},{"attributes":{"bold":true},"insert":"MAYBE_DIRTY"},{"insert":"，立刻检查"},{"attributes":{"bold":true},"insert":"$state变量"},{"insert":"版本号与自己记录的版本号，发现对不齐就重新执行注册的运算函数，并将运算结果与之前的缓存做对比，如果相等则不更新自身版本号，如果不相等则更新自身版本号，更新自身状态为"},{"attributes":{"bold":true},"insert":"CLEAN"},{"insert":"。然后返回到"},{"attributes":{"bold":true},"insert":"$derived变量1"},{"insert":"。\n"},{"attributes":{"bold":true},"insert":"$derived变量1"},{"insert":"开始检查"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"当前版本号与自己记录的版本号，然后做与"},{"attributes":{"bold":true},"insert":"$derived变量2"},{"insert":"同样的事，并返回到"},{"attributes":{"bold":true},"insert":"$effect"},{"insert":"；\n"},{"attributes":{"bold":true},"insert":"$effect"},{"insert":"检查"},{"attributes":{"bold":true},"insert":"$derived变量1"},{"insert":"这个依赖有没有变化，有变化则执行，没变化则不动\n\n"},{"insert":{"listItemContainer":true}},{"insert":"流程总结"},{"attributes":{"header":2},"insert":"\n"},{"insert":"\n总结一下这个流程：\n当"},{"attributes":{"bold":true},"insert":"下游的依赖"},{"insert":"发生更新后，会立即通知"},{"attributes":{"bold":true},"insert":"上游的订阅者"},{"insert":"，订阅者并不立即更新而是先更新自己的状态为MAYBE_DIRTY；\n然后继续通知它的上游订阅者，这中间的订阅者都做同样的事；\n\n"},{"insert":{"listItemContainer":true}},{"insert":"当到达顶端订阅者后，它开始执行的第一件事是先检查所有的依赖是否版本有变化，如果都没变化，那么自己根本就不用执行，如果任何一个有变化那么自己重新执行；\n\n"},{"insert":{"listItemContainer":true}},{"insert":"那么依赖的检查就是一个递归的过程，它会先要求下游依赖检查自己，当最底端依赖更新完自身就开始上游更新自身的过程，一直到最顶端确认是否有有任何一个依赖发生了版本变化。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"我还想用一个最近网上很形象的说法来给大家解说，读完后你应该会映像深刻，那么开始！\n\n向上通知流程：\n"},{"insert":{"listItemContainer":"<div class=\"list-item-container\" id=\"your-custom-id-123\"><div class=\"line-container\"><span class=\"list-index\">1. </span><span class=\"list-content\">牛马：“报告大帅A！行情有变！”</span></div><div class=\"line-container\"><span class=\"list-index\">2. </span><span class=\"list-content\">大帅A：“记下了”，“报告大帅B！行情好像有变！”</span></div><div class=\"line-container\"><span class=\"list-index\">3. </span><span class=\"list-content\">大帅B：“记下了”，“报告大大帅！行情好像有变！”</span></div><div class=\"line-container\"><span class=\"list-index\">4. </span><span class=\"list-content\">大大帅：“知道了，现在忙待会看”。</span></div></div>"}},{"insert":{"listItemContainer":true}},{"insert":"\n向下确认流程：\n"},{"insert":{"listItemContainer":"<div class=\"list-item-container\" id=\"your-custom-id-123\"><div class=\"line-container\"><span class=\"list-index\">1. </span><span class=\"list-content\">。。。大大帅忙完清点土特产的活后。。。</span></div><div class=\"line-container\"><span class=\"list-index\">2. </span><span class=\"list-content\">大大帅：“小B，上次的事你现在去干，完事儿汇报”</span></div><div class=\"line-container\"><span class=\"list-index\">3. </span><span class=\"list-content\">大帅B：翻了记录，“小A，上次的事你现在去干，完事儿汇报”</span></div></div>"}},{"insert":{"listItemContainer":true}},{"insert":"\n\n向上汇报流程：\n"},{"insert":{"listItemContainer":"<div class=\"list-item-container\" id=\"your-custom-id-123\"><div class=\"line-container\"><span class=\"list-index\">1. </span><span class=\"list-content\">大帅A：翻了记录，分析上次的行情变化，决定更改部署，整理完PPT，“报告大帅A！部署已更改！”</span></div><div class=\"line-container\"><span class=\"list-index\">2. </span><span class=\"list-content\">大帅B：分析小A的结果，决定更改部署，整理完PPT，“报告大大帅！部署已更改！”</span></div><div class=\"line-container\"><span class=\"list-index\">3. </span><span class=\"list-content\">大大帅：“干得不错！”，根据小B的汇报开始重新部署。</span></div></div>"}},{"insert":{"listItemContainer":true}},{"insert":"\n想象一下，如果中间的大帅A和大帅B任何一个认为行情变化不影响当前部署，那么就不会更改部署，剩下的所有上游也就不用更改部署。\n\n这就是这个机制的高效的地方，如何没有这个检查机制，以前的流程是如果任何一个依赖更新了上游都会无条件更新和执行，这显然没有把效率最优化。\n\n$derived的依赖版本检查代码"},{"attributes":{"header":2},"insert":"\n"},{"insert":"好了，我们先搞明白理论上的设计，再看代码，那才是事半功倍！\n......"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"export function derived(fn: DerivedFntType) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    let cached: DerivedFnResultType"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    let status: 'DIRTY' | 'MAYBE_DIRTY' | 'CLEAN' = 'DIRTY'"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"    const subs = new Set<RunnerType | RecomputeRunnerType>()"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"  "},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    function recomputeRunner() {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        // 清理之前的依赖（如果有）"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        // 将自身入栈"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        ..."},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"        try { "},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            const newValue = fn() // rebuild dependencies"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            if (newValue !== cached) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                recomputeRunner._version += 1"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                cached = newValue"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            return newValue"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        } finally {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            status = 'CLEAN'"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            ......"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"    recomputeRunner.deps = new Set<RecomputeRunnerDepsType>()"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    recomputeRunner._version = 0;"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    recomputeRunner.__run = () => {"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"        ......"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"        status = 'MAYBE_DIRTY'"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"        ......"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n\n"},{"insert":"    ......"},{"attributes":{"code-block":"javascript"},"insert":"\n\n\n"},{"insert":"    recomputeRunner.checkDepsVersion = () => {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        recomputeRunner.deps?.forEach(dep => {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            dep.target?.checkDepsVersion?.()"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            if (dep?._version_snapshot !== dep.target?._version) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                return recomputeRunner()"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        })"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"    return {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        get value() {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            if (status === 'DIRTY') {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                recomputeRunner() // 更新依赖关系 更新状态 更新最新值"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            } else if (status === 'MAYBE_DIRTY') { // 建立依赖前先检查依赖版本和更新状态"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                // 依赖检查并更新"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                recomputeRunner.checkDepsVersion()"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            // 建立双向依赖订阅关系"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            const current = getCurrentRunner()"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            if (current) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                "},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                ......"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"                current.deps.add({ // NOTE: for cleanup we need a signal-like ref"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                    _subs: subs,"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                    target: recomputeRunner,"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                    _version_snapshot: recomputeRunner._version,"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                })"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            ......"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            return cached"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"// 导出一个 React Hook"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"export const $derived = (fn: DerivedFntType) => {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    let _derived_result_ref = useRef<{value: any}>(null)"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"    if (!_derived_result_ref.current) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        _derived_result_ref.current = derived(fn)"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"    return _derived_result_ref.current"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"现在我们对代码稍作解读，有了以上的流程分析，想必你看起代码来会势如破竹！\n\n"},{"insert":{"listItemContainer":true}},{"insert":"这里我们仅列出更改后新增的关键代码，这是基于之前的"},{"attributes":{"link":"https://blog.hiou.top/dollar-derived"},"insert":"$derieved"},{"insert":"所做的代码更新，我们为$derived增加了自身的版本，和依赖版本检查，并将之前单一的"},{"attributes":{"bold":true},"insert":"Dirty"},{"insert":"状态更改为三个单独的状态：'"},{"attributes":{"bold":true},"insert":"DIRTY' | 'MAYBE_DIRTY' | 'CLEAN"},{"insert":"'，同时默认为"},{"attributes":{"bold":true},"insert":"DIRTY"},{"insert":"状态，这是用于首次访问变量的时候初始化默认执行一次计算函数得到初始值。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"另外，我们不再像之前一样把"},{"attributes":{"bold":true},"insert":"$derived"},{"insert":"作为一个普通函数导出，而是用与之前同样的作案手法，导出一个"},{"attributes":{"bold":true},"insert":"React Hook"},{"insert":"，因为$derived本身的设计原则就是在最外层作为一个声明型依赖。\n在获取一个"},{"attributes":{"bold":true},"insert":"$derived"},{"insert":"值的时候，我们先做依赖版本检查，这是一个递归的过程，从最底层向上开始，根据依赖版本更新自己身的状态和返回值。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"另一个需要特别注意的地方是，我们是如何记录当前依赖的版本的，这涉及到之后的依赖版本对比。我们是在建立"},{"attributes":{"bold":true},"insert":"双向依赖订阅关系"},{"insert":"的时候，向订阅者告知当前版本的一个快照值，并将自身引用也传递过去，方便上游获取自身最新的版本值。我们通过在"},{"attributes":{"bold":true},"insert":"current.deps.add"},{"insert":"的参数里增加"},{"attributes":{"bold":true},"insert":"target、_version_snapshot"},{"insert":"参数来传递这两个信息。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"除了"},{"attributes":{"bold":true},"insert":"$derived"},{"insert":"，我们还需要对"},{"attributes":{"bold":true},"insert":"$state"},{"insert":"增加版本相关内容\n\n$state的依赖版本检查代码"},{"attributes":{"header":2},"insert":"\n"},{"insert":"function makeProxy(obj: any) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    ......"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    let targetForDeps = { _version: 0 };"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"    const proxy = new Proxy(obj, {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        get(target, key, receiver) {"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            ......"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            if (currentRunner) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"              currentRunner.deps.add({ // add runner deps"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                _subs: targetSubs.addSubsIfNeed(target, key, currentRunner),"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                _version_snapshot: targetForDeps._version,"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"                target: targetForDeps"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"              })"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            ......"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        },"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        set(target, key, value, receiver) {"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"            ......"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            targetForDeps._version++"},{"attributes":{"code-block":"javascript"},"insert":"\n\n"},{"insert":"            ......"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"    })"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":"javascript"},"insert":"\n"},{"insert":"这里也仅列出基于"},{"attributes":{"link":"https://blog.hiou.top/dollar-state"},"insert":"原来的$state"},{"insert":"基础上的增加的代码，如$derived一样，在建立依赖关系的时候将当前自身的版本号快照和一个能代表自身的对象传递给订阅者，里面仅包含一个获取当前最新版本的值，在更新的时候我们更新这个对象里的版本值。使用一个额外的对象来代表自身是因为$state使用了Proxy，这是一个特殊的对象不能直接传给订阅者。另一方面，我们仅需传给订阅者它需要的内容即可，并不一定要把自己的真实引用传递过去。\n到此为止我们已经彻底搞懂了Svelte的版本检查更新机制，通过进一步的细致检查来提高运行效率。\n对于$effect的依赖版本检查，大家则可以自己思考一下，想必已是轻轻松松。\n\n如何将原始值作为$state、$derived参数\n"},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":"\n"},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":"最后，我们在稍微深入探究一下Svelte是如何在使用$state、$derived时能够直接将原始值作为参数，比如$state(0)，作为一个预热。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"我们知道直接使用代理是无法将原始值作为参数的，只能代理对象类型。但我们的思考仅停留在逻辑代码层面，也就是运行时层面。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"如果我们能在编译的时候，将 const count = $state(0) 这句代码直接替换成 let count = $.source(0)，然后再把访问 count 的语句比如 count++ 替换成 "},{"attributes":{"bold":true},"insert":"$.set"},{"insert":"(count, "},{"attributes":{"bold":true},"insert":"$.get"},{"insert":"(count) + 1)，然后在文件的顶部加入引入 $ 的语句呢？\n是的，Svelte就是这么做的，既然在运行时层面不行，那就把它挪到编译时解决。然后在运行时环境实现编译时用到的"},{"attributes":{"bold":true},"insert":"set、get、source"},{"insert":"等等这不就解决了！\n\n"},{"insert":{"listItemContainer":true}},{"insert":"到此，你一定注意到了，这里对于一个响应式变量的声明、访问、设置分别做了实现。没错，Svelte在实现时将这些逻辑做了分离实现以达到解耦的效果。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"你可以想象一个小孩玩机器人玩具，玩具什么样子由这个玩具的组成部分是什么状态决定，而这个玩具是什么状态又由这个小孩的手决定，然后获取当前玩具的样子又由这个小孩的眼睛来观察。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"想必你已经恍然大悟，这个响应式变量就是这个玩具，set函数就是这个这个小孩的手，get函数就是小孩的眼睛。\n这个响应式变量只负责记录当前的状态和值，set负责操作更新响应式变量的状态和值，get负责访问响应式变量的值。这就将各个逻辑进行了解耦！\n\n"},{"insert":{"listItemContainer":true}},{"insert":"因为操作响应式变量有一些公共的逻辑，比如上下文的出栈入栈，依赖版本检查，建立双向依赖订阅关系等等，这些就可以集中统一到set函数中，对于其它函数也一样。\n\n"},{"insert":{"listItemContainer":true}},{"insert":"那么接下来的文章，我们将继续深入探究，如何将这种运行时和编译时相配合的行为，在工程化层面引入到React的世界里！\n\n"},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}},{"insert":{"listItemContainer":true}}]}

const safeHtml = getSafeHtmlFromDelta(TestDeltaString)

const result = {
    content: safeHtml,
}

export default result;

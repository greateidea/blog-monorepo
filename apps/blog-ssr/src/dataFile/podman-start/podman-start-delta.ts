import { getSafeHtmlFromDelta } from "../../utils"

const TestDeltaString = {"ops":[{"insert":"这次我们使用Podman的命令，创建和启动三个基本的容器。通过实践来了解Podman容器的基本使用方式和它如何运行。\n\n实践目标"},{"attributes":{"header":2},"insert":"\n"},{"insert":"这次我们实践的目标首先是启动三个容器，它们分别是nginx、node、mongodb，这也是后端最基本的服务体系，通过nginx做反向代理并访问后端服务，通过node来部署后端服务，而mongodb来作为数据库服务，然后再介绍什么是Podman的pod，并将这三个容器放入同一个pod来运行。这里我们先暂且不去讨论nginx的相关配置文件是如何配置的，以及nginx和mongodb是否应该通过容器来部署的问题，我们只是通过部署这三个容器来实践如何使用Podman容器。\n\n启动 nginx 容器"},{"attributes":{"header":2},"insert":"\n"},{"insert":"我们先直接来看看nginx容器的基本启动命令：\npodman run --rm --name my-custom-openresty-container \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret source=load_stage,target=/run/secrets/load_stage,type=mount \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e LOAD_STAGE_FILE=/run/secrets/load_stage \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf:ro \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/conf.d:/etc/nginx/conf.d \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/letsencrypt:/etc/letsencrypt:ro \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/audios:/var/secure-audios:ro \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/nginx-logs:/usr/local/openresty/nginx/logs \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -d openresty:alpine"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"现在开始逐步解释这个命令。先来看看：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558113342,"text":"podman run --rm --name my-custom-openresty-container  -d openresty:alpine","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n这一段表示使用 "},{"attributes":{"bold":true},"insert":"run "},{"insert":"来创建和启动一个名为 “"},{"attributes":{"italic":true},"insert":"my-custom-openresty-container"},{"insert":"” 的容器，它使用的镜像是最新的 "},{"attributes":{"italic":true},"insert":"alpine "},{"insert":"版本的openresty，-d 则表示命令执行后在后台运行，--rm 表示容器如果停止就删除这个容器 。启动成功后，使用 "},{"attributes":{"bold":true},"insert":"podman ps "},{"insert":"命令后，你会看到一个正在运行的名为 “"},{"attributes":{"italic":true},"insert":"my-custom-openresty-container"},{"insert":"” 的容器。再来看看：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558120020,"text":"-e LOAD_STAGE_FILE=/run/secrets/load_stage","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n它表示你向运行的容器里注入了一个环境变量，环境变量的名字叫做 LOAD_STAGE_FILE，变量的值是 /run/secrets/load_stage，它是一个文件路径，接下来看看：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558129505,"text":"--secret source=load_stage,target=/run/secrets/load_stage,type=mount","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n这一行表示使用了Podman的 "},{"attributes":{"bold":true},"insert":"secret "},{"insert":"并将其注入到运行的容器中。在 Podman 里，"},{"attributes":{"code":true},"insert":"secret"},{"insert":" 是一种安全存储敏感信息（如密码、API 密钥、证书私钥等） 的机制。我们将一些敏感信息例如数据库密码放入 "},{"attributes":{"bold":true},"insert":"secret "},{"insert":"然后，然后注入运行中的容器中。这里我们通过 "},{"attributes":{"bold":true},"insert":"target=/run/secrets/load_stage "},{"insert":"手动指定将 secret 的内容挂载到容器内的 /run/secrets/load_stage 路径中。这样我们就可以在容器中通过访问 /run/secrets/load_stage 这个地方来得到 secret 的内容。\n\n但我们并不会在容器中直接硬编码 /run/secrets/load_stage 这个值来访问它，而是将这个路径值放到环境变量中，然后在容器中通过访问这个环境变量来得到这个文件路径，也就是刚才的 "},{"attributes":{"bold":true},"insert":"LOAD_STAGE_FILE "},{"insert":"这个环境变量。这样即便我们改变了secret挂载的路径，也可以通过从外部同步改变环境变量，让我们始终能在容器中获得正确的路径值。\n\n那么如何创建一个secret？很简单！在主机上执行命令：\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558137374,"text":"echo \"my-secret-password\" | podman secret create db_password -","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n想想如果我们直接使用 “-e MYSQL_PASSWORD=supersecret” 这样的环境变量来存放密钥信息，不仅直接暴露在命令中也会在留存在主机的命令历史中，这使得重要信息过于暴露，十分不安全。然后我们继续看：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558143941,"text":"-v /your-path/nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf:ro","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n这一行的组成是 -v value:path:ro ，"},{"attributes":{"code":true},"insert":"-v"},{"insert":" 参数用于把"},{"attributes":{"bold":true},"insert":"主机上的目录或文件"},{"insert":"映射到"},{"attributes":{"bold":true},"insert":"容器内部"},{"insert":"，实现文件共享、持久化数据或配置注入。这里的value表示主机上的文件路径，也可以是一个创建好的命名卷（后面会解释什么是命名卷）。那么这一句的含义就是：将运行Podman的主机上的 "},{"attributes":{"bold":true},"insert":"/your-path/nginx.conf"},{"insert":" 路径映射到容器的"},{"attributes":{"bold":true},"insert":"/usr/local/openresty/nginx/conf/nginx.conf "},{"insert":"路径，最终将主机上的内容共享到容器中，这样openresty就可以读取http级配置。最后的 "},{"attributes":{"bold":true},"insert":":ro"},{"insert":" 则表示只读。/usr/local/openresty/nginx/conf/nginx.conf 是镜像官方指定的值。其余的：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558151455,"text":"-v /your-path/conf.d:/etc/nginx/conf.d","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t表示主机中nginx的server块配置文件映射到容器的/etc/nginx/conf.d，这样openresty就可以读取server块配置。/etc/nginx/conf.d 是镜像官方指定的值。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558156921,"text":"-v /your-path/nginx-logs:/usr/local/openresty/nginx/logs","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t则表示openresty的日志文件会放在容器 /usr/local/openresty/nginx/logs，并共享到主机的 /your-path/nginx-logs 路径下。/usr/local/openresty/nginx/logs 是镜像官方指定的值。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558166071,"text":"-v /your-path/letsencrypt:/etc/letsencrypt:ro","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t这一句则表示https证书的挂载位置且只读。将我们的https证书存放在主机的/your-path/letsencrypt后，共享到容器的 /etc/letsencrypt 目录下，这样我们就可以在nginx中通过配置这个容器路径来读取我们的https证书。比如：\n\nserver {"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" listen 443 ssl;"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" ..."},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" # SSL配置"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" ..."},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"\n这里再解释一下，通常使用Let’s Encrypt 生成的证书位于/etc/letsencrypt/live/your-domain/下，由于我们使用了容器并且没有设置这个位置的读取权限，所以将这个目录里的证书完整的复制到了/your-path/letsencrypt下，如果证书续期更新你又不想手动复制，Certbot 也提供了 --deploy-hook的续期钩子，你可以利用这个钩子执行复制。最后我们来看一下：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558173720,"text":"-v /your-path/audios:/var/secure-audios:ro","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n这是一个我们自己指定的配置项，它表示将主机 /your-path/audios下的内容共享到容器的 /var/secure-audios 下，并且只读。这样我们可以自己读取主机里存放的一些内容，比如在通过在nginx配置中返回容器 /var/secure-audios 下的音频资源。\n\n最后，你可能会好奇，为什么我们使用的是openresty而不是直接使用nginx的官方镜像？这是因为openresty同样使用了nginx但是它可以在nginx的配置文件中使用Lua脚本，然后通过脚本我们可以读取之前挂载的 secret 所在的容器文件。比如我们可以在http级配置中这样写：\nhttp {"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" ..."},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" lua_shared_dict my_cache 1m;"},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":" init_by_lua_block {"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" -- 启动时读密钥"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" local secret_path = os.getenv(\"LOAD_STAGE2_FILE\") or \"/run/secrets/load_stage2\""},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" local file, err = io.open(secret_path, \"r\")"},{"attributes":{"code-block":"plain"},"insert":"\n\n"},{"insert":" if not file then"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" ngx.log(ngx.ERR, \"Failed to open secret file at \" .. secret_path .. \": \", err)"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" end"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" local secret = (file:read(\"*a\"):gsub(\"^%s*(.-)%s*$\", \"%1\"))"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" file:close()"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" -- 存到全局变量"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" package.loaded.my_secret = secret"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"\n接下来我们完成下一个小目标，启动node容器。\n\n启动 node 容器"},{"attributes":{"header":2},"insert":"\n"},{"insert":"我们还是直接看启动命令：\npodman run --rm --name customer-node-container \\"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" --secret mongo_app_user,type=mount,target=/run/secrets/mongo_app_user \\"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" --secret mongo_app_pass,type=mount,target=/run/secrets/mongo_app_pass \\"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" -e MONGO_APP_USERNAME_FILE=/run/secrets/mongo_app_user \\"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" -e MONGO_APP_PASSWORD_FILE=/run/secrets/mongo_app_pass \\"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":" -d customer-node-image"},{"attributes":{"code-block":"plain"},"insert":"\n"},{"insert":"\n相信看完nginx容器启动命令的解释后，到这里已经是手拿把掐的了。我们就简单解释：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558181723,"text":"--secret mongo_app_user,type=mount,target=/run/secrets/mongo_app_user","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558186974,"text":"--secret mongo_app_pass,type=mount,target=/run/secrets/mongo_app_pass","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n表示我们将数据库的账号密码通过 "},{"attributes":{"bold":true},"insert":"secret "},{"insert":"挂载到容器，并存放到容器的文件中。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558194556,"text":"-e MONGO_APP_USERNAME_FILE=/run/secrets/mongo_app_user","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558199070,"text":"-e MONGO_APP_PASSWORD_FILE=/run/secrets/mongo_app_pass","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n表示我们将存放 secret"},{"attributes":{"bold":true},"insert":" "},{"insert":"信息的文件路径值，注入到容器的环境变量中。然后在容器中，我们的node程序就可以通过读取文件中的内容来获取 secret"},{"attributes":{"bold":true},"insert":" "},{"insert":"信息。接着我们完成下一个小目标，启动mongodb容器。\n\n启动mongodb容器"},{"attributes":{"header":2},"insert":"\n"},{"insert":"podman run --rm -d \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --name my_mongodb \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret mongo_root_username,type=mount,target=/run/secrets/mongo_root_username \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --secret mongo_root_password,type=mount,target=/run/secrets/mongo_root_password \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e MONGO_INITDB_ROOT_USERNAME_FILE=/run/secrets/mongo_root_username \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -e MONGO_INITDB_ROOT_PASSWORD_FILE=/run/secrets/mongo_root_password \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v mongodb_data:/data/db:Z \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" -v /your-path/mongodb_init/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:Z \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --user mongodb \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --security-opt no-new-privileges \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --memory=1g \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --memory-swap=1g \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --health-interval=30s \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" mongo \\"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":" --wiredTigerCacheSizeGB 1"},{"attributes":{"code-block":"bash"},"insert":"\n"},{"insert":"\n来看一下这个命令做了哪些事情：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558207371,"text":"--secret mongo_root_username,type=mount,target=/run/secrets/mongo_root_username","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558212839,"text":"--secret mongo_root_password,type=mount,target=/run/secrets/mongo_root_password","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558220354,"text":"-e MONGO_INITDB_ROOT_USERNAME_FILE=/run/secrets/mongo_root_username","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558226287,"text":"-e MONGO_INITDB_ROOT_PASSWORD_FILE=/run/secrets/mongo_root_password","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n这表示将数据库根用户账号密码通过 secret 注入到容器文件中，并通过  MONGO_INITDB_ROOT_USERNAME_FILE 和 MONGO_INITDB_ROOT_PASSWORD_FILE 环境变量来记录存放 secret 信息的文件路径值，这两个环境变量是镜像官方指定的值，会在首次启动数据库时读取它们并执行创建根用户的操作。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558233022,"text":"-v mongodb_data:/data/db:Z","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n表示容器在 /data/db下存放数据并共享到主机的 mongodb_data 中来持久化保存数据， 这里的 mongodb_data 是一个"},{"attributes":{"bold":true},"insert":"命名卷（文章的最后部分有解释）"},{"insert":"。"},{"attributes":{"bold":true},"insert":":Z"},{"insert":"则表示一个 SELinux（安全增强型 Linux）相关的标记选项，它控制容器与主机之间挂载目录的安全标签，为这个挂载目录分配一个“私有的 SELinux 标签”，让该目录只允许这个容器访问。/data/db 是镜像官方指定的值。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558248320,"text":"-v /your-path/mongodb_init/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:Z","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n这一行表示数据库首次启动时，执行挂载的初始化js文件，你可以在这个文件中以根用户的身份执行数据库的初始化工作比如创建应用用户、创建和切换数据库、创建集合、插入初始数据等等。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558257870,"text":"--user mongodb","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t表示让容器内的进程以 "},{"attributes":{"bold":true,"code":true},"insert":"mongodb"},{"attributes":{"bold":true},"insert":" 用户"},{"insert":"（非 root）运行，这通常是镜像内预先定义的用户。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558307656,"text":"--security-opt no-new-privileges","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t表示防止容器进程在运行时获取比启动时更多的权限，这样即使容器进程被攻击，也不能提升为 root、获取新的 capabilities、绕过 seccomp 或 AppArmor 限制等等。\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558314471,"text":"--memory=1g","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t表示限制容器最多使用 1GB 物理内存\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558323119,"text":"--memory-swap=1g","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t限制容器使用的总内存（物理 + swap）为 1GB，不能再使用额外的 swap 空间\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558329452,"text":"--health-interval=30s","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t设置健康检查（healthcheck）执行间隔为 30 秒\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558334906,"text":"--wiredTigerCacheSizeGB 1","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\t这是 MongoDB 自身的启动参数，限制 WiredTiger 存储引擎的缓存为 1GB\n\n先阶段性总结一下，到这里我们已经成功学会通过Podman命令创建并启动了三个容器（nginx、node、mongodb）,同时如果做好相应的配置，比如nginx配置，node访问数据库的配置等等，就已经可以运行一个基本的后端服务流程。\n\n最后，我们来完成最后一个小目标，将它们运行在一个pod中\n\n"},{"attributes":{"bold":true},"insert":"Podman的pod"},{"insert":"\n\n先来简单介绍一下什么是 "},{"attributes":{"bold":true},"insert":"pod"},{"insert":"。Podman 的 "},{"attributes":{"bold":true},"insert":"pod（工作单元）"},{"insert":" 是一个共享同一个网络、命名空间、IPC、UTS 等资源的容器组。换句话说：一个 pod = 多个共享同一“环境”的容器。两个容器在同一个 Pod 里，它们共享同一个 IP、同一个网络命名空间、端口，可以直接通过 "},{"attributes":{"code":true},"insert":"localhost"},{"insert":" 通信，同时它也基本等同于Kubernetes 的基本运行单元 Pod。\n\n以我们三个容器举例，如果我们的 nginx 使用443端口，node监听的是3000端口，mongodb监听的是27017端口，那么我们则可以创建一个 pod，这个pod只暴露443端口，将这个三个容器都放入这个pod里执行，则外界只能通过https访问服务器，并由这个pod的443端口接收，接收由 pod 中的 nginx 接收，并通过配置转到本地监听3000端口的 node 服务，接着node服务又可以访问本地监听27017端口的mongodb。于是我们通过一个简单的pod对外隐藏了我们的 node 服务和 mongodb 服务。\n\n那该怎么做呢？依然很简单，执行命令：\n\n"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558355006,"text":"podman pod create --name your-pod -p 443:443","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":"\n\n这一句表示创建一个名为 “"},{"attributes":{"italic":true},"insert":"your-pod"},{"insert":"” 的 pod，并且将主机的443映射到pod内的443端口，这样外界对主机443端口的访问将会转到pod内的443端口，并由我们的 nginx 容器接管。如果你还想开放更多端口，只需在这条命令之后追加 "},{"attributes":{"bold":true},"insert":"-p 端口1：端口2"},{"insert":"。\n\n最后，在以上三个容器的启动命令中的第二行增加一句："},{"attributes":{"bold":true},"insert":"--pod your-pod，"},{"insert":"这样启动的容器就会自动加入同一个pod。\n\n"},{"attributes":{"bold":true},"insert":"可能会遇到的问题"},{"insert":"\n\n这里再解决一些你可能会遇到的问题，比如启动 nginx 无法绑定 443端口。这是因为 Linux 下小于 1024 的端口是特权端口，只有 root 权限才能绑定，我们用的是 "},{"attributes":{"bold":true},"insert":"rootless Podman"},{"insert":"（非 root 用户运行容器），所以无法绑定 443 端口，会导致报错：\nrootlessport cannot expose privileged port 443, you can add 'net.ipv4.ip_unprivileged_port_start=443' to /etc/sysctl.conf (currently 1024)\n\n解决办法是允许 rootless Podman 使用低端口，编辑 sysctl 配置："},{"attributes":{"bold":true},"insert":"sudo vim /etc/sysctl.conf"},{"insert":"，然后添加或修改："},{"attributes":{"bold":true},"insert":"net.ipv4.ip_unprivileged_port_start=443"},{"insert":"，保存退出执行："},{"attributes":{"bold":true},"insert":"sudo sysctl -p"},{"insert":"。此时，再运行我们的 Podman 命令，rootless 容器就可以绑定 443 端口了。\n\n另一个你可能遇到的问题可能是：nginx写日志的挂载文件和mongdb的数据存储挂载文件也会遇到 rootless  无权限写的问题，这时你可以执行 sudo chown 相关的命令给予相应的权限，或者使用命名卷，通过："},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558370358,"text":"podman volume create mydata","renderAsBlock":false,"className":"blue700-tag"}}},{"attributes":{"bold":true},"insert":" "},{"insert":"来在主机下创建一个命名卷，并替代之前使用的挂载目录。\n\n还可以通过 "},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558383154,"text":"podman volume ls","renderAsBlock":false,"className":"blue700-tag"}}},{"insert":" 命令查看当前已创建的命名卷，"},{"attributes":{"bold":true},"insert":{"blue700-tag":{"id":1761558376986,"text":"podman volume inspect mydata","renderAsBlock":false,"className":"blue700-tag"}}},{"attributes":{"bold":true},"insert":" "},{"insert":"命令查看 “mydata” 命名的具体信息比如它对应的实际文件路径。\n\n总结一下，我们完成了三个容器的创建和启动，并通过将它们放在一个pod里运行来隐藏我们的服务，最后解决了一些实践过程中可能会遇见的问题。到此为止，通过实践你已经对Podman的掌握相当不错了。但还没完呢，我们还会面临一个更加重要的问题，那就是服务持久化。我们的命令在终端执行，一旦我们从终端退出，那已经运行的容器也会随之退出，这肯定不是我们想要的。在接下来的文章，我们将再次通过实践，解决这个问题。\n\n"}]}

const safeHtml = getSafeHtmlFromDelta(TestDeltaString)

const result = {
    content: safeHtml,
}

export default result;

